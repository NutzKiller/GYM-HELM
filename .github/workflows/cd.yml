name: CD Workflow

on:
  workflow_run:
    workflows:
      - CI Workflow
    types:
      - completed

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the main repository code
      - name: Check out main repository
        uses: actions/checkout@v3

      # Step 2: Set up Terraform
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      # Step 3: Create GCP credentials file
      - name: Create GCP credentials file
        run: |
          mkdir -p terraform
          echo "${{ secrets.GCP_CREDENTIALS_FILE_B64 }}" | base64 --decode > terraform/gcp_credentials.json
          echo "âœ… GCP credentials file created."

      # Step 4: Validate GCP Authentication
      - name: Verify GCP Authentication
        run: |
          gcloud auth list
          gcloud config list

      # Step 5: Set up Cloud SDK
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: ${{ secrets.GCP_PROJECT }}
          service_account_key_file: terraform/gcp_credentials.json
          export_default_credentials: true

      # (Optional) -- If you experience authentication plugin errors, you can add:
      # - name: Install gke-gcloud-auth-plugin
      #   run: gcloud components install gke-gcloud-auth-plugin --quiet

      # Step 6: Import existing GKE cluster if present
      - name: Import existing cluster if present
        working-directory: terraform
        env:
          TF_VAR_GCP_CREDENTIALS_FILE: "gcp_credentials.json"
          TF_VAR_GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          TF_VAR_GCP_REGION: ${{ secrets.GCP_REGION }}
          GOOGLE_APPLICATION_CREDENTIALS: "gcp_credentials.json"
        run: |
          echo "Checking if cluster 'gym-cluster' exists..."
          if gcloud container clusters list --project=${TF_VAR_GCP_PROJECT} --region=${TF_VAR_GCP_REGION} | grep -q "gym-cluster"; then
            echo "Cluster gym-cluster exists."
            if terraform state list | grep -q "google_container_cluster.primary"; then
              echo "Cluster already imported into state."
            else
              echo "Importing gym-cluster into Terraform state..."
              terraform import google_container_cluster.primary projects/${TF_VAR_GCP_PROJECT}/locations/${TF_VAR_GCP_REGION}/clusters/gym-cluster
            fi
          else
            echo "Cluster gym-cluster does not exist. Terraform will create it."
          fi

      # Step 7: Configure kubectl to connect to GKE
      - name: Get GKE Credentials
        uses: google-github-actions/get-gke-credentials@v1
        with:
          cluster_name: gym-cluster
          location: ${{ secrets.GCP_REGION }}
          project_id: ${{ secrets.GCP_PROJECT }}
        env:
          GOOGLE_APPLICATION_CREDENTIALS: terraform/gcp_credentials.json

      # Step 8: Initialize Terraform (ensure backend is configured)
      - name: Initialize Terraform
        working-directory: terraform
        env:
          TF_VAR_GCP_CREDENTIALS_FILE: "gcp_credentials.json"
          TF_VAR_GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          TF_VAR_GCP_REGION: ${{ secrets.GCP_REGION }}
          GOOGLE_APPLICATION_CREDENTIALS: "gcp_credentials.json"
        run: terraform init -input=false -reconfigure

      # Step 9: Check and Import Namespace
      - name: Check and Import Namespace
        working-directory: terraform
        env:
          TF_VAR_GCP_CREDENTIALS_FILE: "gcp_credentials.json"
          TF_VAR_GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          TF_VAR_GCP_REGION: ${{ secrets.GCP_REGION }}
          TF_VAR_DATABASE_URL: ${{ secrets.DATABASE_URL }}
          TF_VAR_SECRET_KEY: ${{ secrets.SECRET_KEY }}
          TF_VAR_MY_GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
          TF_VAR_image_tag: "v1.0.${{ github.run_number }}"
          GOOGLE_APPLICATION_CREDENTIALS: "gcp_credentials.json"
        run: |
          echo "Checking if namespace gym-namespace exists..."
          if kubectl get namespace gym-namespace >/dev/null 2>&1; then
            echo "Namespace gym-namespace exists."
            if terraform state list | grep -q "kubernetes_namespace.gym"; then
              echo "Namespace already imported into Terraform state."
            else
              echo "Importing gym-namespace into Terraform state..."
              terraform import -input=false -lock=false kubernetes_namespace.gym gym-namespace
            fi
          else
            echo "Namespace gym-namespace does not exist. Terraform will create it."
          fi

      # Step 9.5: Patch and Force Delete Namespace if Terminating
      - name: Patch and Force Delete Namespace (if needed)
        working-directory: terraform
        env:
          GOOGLE_APPLICATION_CREDENTIALS: "gcp_credentials.json"
        run: |
          echo "Checking namespace gym-namespace status..."
          if kubectl get namespace gym-namespace >/dev/null 2>&1; then
            NS_PHASE=$(kubectl get namespace gym-namespace -o jsonpath='{.status.phase}')
            echo "Namespace gym-namespace phase: $NS_PHASE"
            if [ "$NS_PHASE" = "Terminating" ]; then
              echo "Namespace gym-namespace is terminating. Removing finalizers..."
              # Install jq if not present
              if ! command -v jq >/dev/null 2>&1; then
                sudo apt-get update && sudo apt-get install -y jq
              fi
              kubectl get namespace gym-namespace -o json | jq '.spec.finalizers=[]' | kubectl replace --raw "/api/v1/namespaces/gym-namespace/finalize" -f -
              echo "Force deleting namespace gym-namespace..."
              kubectl delete namespace gym-namespace --grace-period=0 --force || echo "Force delete issued."
              echo "Waiting up to 60 seconds for namespace gym-namespace to vanish..."
              kubectl wait --for=delete namespace/gym-namespace --timeout=60s || echo "Namespace gym-namespace still exists after timeout. Proceeding anyway."
            else
              echo "Namespace gym-namespace is in phase: $NS_PHASE. No patch required."
            fi
          else
            echo "Namespace gym-namespace not found; skipping patch."
          fi

      # Step 10: Apply Terraform Configuration (Deploys the Helm Release)
      - name: Apply Terraform Configuration
        working-directory: terraform
        env:
          TF_VAR_GCP_CREDENTIALS_FILE: "gcp_credentials.json"
          TF_VAR_GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          TF_VAR_GCP_REGION: ${{ secrets.GCP_REGION }}
          TF_VAR_DATABASE_URL: ${{ secrets.DATABASE_URL }}
          TF_VAR_SECRET_KEY: ${{ secrets.SECRET_KEY }}
          TF_VAR_MY_GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
          TF_VAR_image_tag: "v1.0.${{ github.run_number }}"
          GOOGLE_APPLICATION_CREDENTIALS: "gcp_credentials.json"
        run: terraform apply -auto-approve -input=false

      # Step 11: Validate Kubernetes Connection
      - name: Validate Kubernetes Connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      # Step 12: Ensure Firewall Rule for GKE (if not already set)
      - name: Ensure Firewall Rule for GKE
        run: |
          gcloud compute firewall-rules create allow-gke-5000 \
            --allow=tcp:5000 \
            --target-tags=gke-gym-cluster \
            --source-ranges=0.0.0.0/0 || echo "Firewall rule already exists."

      # Step 13: Retrieve External IP of Helm Release Service
      - name: Retrieve External IP of Helm Release Service
        id: get_ip
        run: |
          echo "Waiting for LoadBalancer IP..."
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc gym-gym-service -n gym-namespace -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EXTERNAL_IP" ]; then
              echo "EXTERNAL_IP=$EXTERNAL_IP" >> $GITHUB_ENV
              echo "External IP: $EXTERNAL_IP"
              break
            fi
            echo "Attempt $i: External IP not assigned yet. Retrying in 10 seconds..."
            sleep 10
          done
          if [ -z "$EXTERNAL_IP" ]; then
            echo "Failed to retrieve External IP."
            exit 1
          fi

      # Step 14: Output External IP
      - name: Output External IP
        run: |
          echo "The application is accessible at http://${{ env.EXTERNAL_IP }}"

      # Step 15: Debug Kubernetes Setup (if needed)
      - name: Debug Kubernetes Setup
        run: |
          echo "Debugging Kubernetes Configuration..."
          kubectl get svc -n gym-namespace
          kubectl get pods -n gym-namespace
          kubectl describe svc gym-gym-service -n gym-namespace
          kubectl describe deployment gym-gym-deployment -n gym-namespace
